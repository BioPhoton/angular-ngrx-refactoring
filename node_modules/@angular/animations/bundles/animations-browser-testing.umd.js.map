{"version":3,"file":"animations-browser-testing.umd.js","sources":["../../../../packages/animations/browser/testing/src/mock_animation_driver.ts","../../../../packages/animations/browser/testing/src/testing.ts","../../../../packages/animations/browser/src/util.ts","../../../../packages/animations/browser/src/render/shared.ts","../../../../../packages/animations/src/players/animation_group_player.ts","../../../../../packages/animations/src/private_export.ts","../../../../../packages/animations/src/players/animation_player.ts","../../../../../packages/animations/src/animation_metadata.ts","../../../../../packages/animations/src/animation_builder.ts","../../../../node_modules/tslib/tslib.es6.js"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../../src/render/animation_driver';\nimport {containsElement, invokeQuery, matchesElement} from '../../src/render/shared';\nimport {allowPreviousPlayerStylesMerge} from '../../src/util';\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationDriver implements AnimationDriver {\n  static log: AnimationPlayer[] = [];\n\n  matchesElement(element: any, selector: string): boolean {\n    return matchesElement(element, selector);\n  }\n\n  containsElement(elm1: any, elm2: any): boolean { return containsElement(elm1, elm2); }\n\n  query(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): MockAnimationPlayer {\n    const player =\n        new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\n    MockAnimationDriver.log.push(<AnimationPlayer>player);\n    return player;\n  }\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationPlayer extends NoopAnimationPlayer {\n  private __finished = false;\n  private __started = false;\n  public previousStyles: {[key: string]: string | number} = {};\n  private _onInitFns: (() => any)[] = [];\n  public currentSnapshot: ɵStyleData = {};\n\n  constructor(\n      public element: any, public keyframes: {[key: string]: string | number}[],\n      public duration: number, public delay: number, public easing: string,\n      public previousPlayers: any[]) {\n    super();\n\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousPlayers.forEach(player => {\n        if (player instanceof MockAnimationPlayer) {\n          const styles = player.currentSnapshot;\n          Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n        }\n      });\n    }\n\n    this.totalTime = delay + duration;\n  }\n\n  /* @internal */\n  onInit(fn: () => any) { this._onInitFns.push(fn); }\n\n  /* @internal */\n  init() {\n    super.init();\n    this._onInitFns.forEach(fn => fn());\n    this._onInitFns = [];\n  }\n\n  finish(): void {\n    super.finish();\n    this.__finished = true;\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.__finished = true;\n  }\n\n  /* @internal */\n  triggerMicrotask() {}\n\n  play(): void {\n    super.play();\n    this.__started = true;\n  }\n\n  hasStarted() { return this.__started; }\n\n  beforeDestroy() {\n    const captures: ɵStyleData = {};\n\n    Object.keys(this.previousStyles).forEach(prop => {\n      captures[prop] = this.previousStyles[prop];\n    });\n\n    if (this.hasStarted()) {\n      // when assembling the captured styles, it's important that\n      // we build the keyframe styles in the following order:\n      // {other styles within keyframes, ... previousStyles }\n      this.keyframes.forEach(kf => {\n        Object.keys(kf).forEach(prop => {\n          if (prop != 'offset') {\n            captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\n          }\n        });\n      });\n    }\n\n    this.currentSnapshot = captures;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {MockAnimationDriver, MockAnimationPlayer} from './mock_animation_driver';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateTimings, AnimationMetadata, AnimationOptions, sequence, ɵStyleData} from '@angular/animations';\n\nexport const ONE_SECOND = 1000;\n\nexport const SUBSTITUTION_EXPR_START = '{{';\nexport const SUBSTITUTION_EXPR_END = '}}';\nexport const ENTER_CLASSNAME = 'ng-enter';\nexport const LEAVE_CLASSNAME = 'ng-leave';\nexport const ENTER_SELECTOR = '.ng-enter';\nexport const LEAVE_SELECTOR = '.ng-leave';\nexport const NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const NG_ANIMATING_SELECTOR = '.ng-animating';\n\nexport function resolveTimingValue(value: string | number) {\n  if (typeof value == 'number') return value;\n\n  const matches = (value as string).match(/^(-?[\\.\\d]+)(m?s)/);\n  if (!matches || matches.length < 2) return 0;\n\n  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n\nfunction _convertTimeValueToMS(value: number, unit: string): number {\n  switch (unit) {\n    case 's':\n      return value * ONE_SECOND;\n    default:  // ms or something else\n      return value;\n  }\n}\n\nexport function resolveTiming(\n    timings: string | number | AnimateTimings, errors: any[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ?\n      <AnimateTimings>timings :\n      parseTimeExpression(<string|number>timings, errors, allowNegativeValues);\n}\n\nfunction parseTimeExpression(\n    exp: string | number, errors: string[], allowNegativeValues?: boolean): AnimateTimings {\n  const regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let duration: number;\n  let delay: number = 0;\n  let easing: string = '';\n  if (typeof exp === 'string') {\n    const matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: ''};\n    }\n\n    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n\n    const delayMatch = matches[3];\n    if (delayMatch != null) {\n      delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\n    }\n\n    const easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = <number>exp;\n  }\n\n  if (!allowNegativeValues) {\n    let containsErrors = false;\n    let startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(`Duration values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(`Delay values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, `The provided timing value \"${exp}\" is invalid.`);\n    }\n  }\n\n  return {duration, delay, easing};\n}\n\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => { destination[prop] = obj[prop]; });\n  return destination;\n}\n\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    copyObj(styles, destination);\n  }\n  return destination;\n}\n\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = styles[prop];\n    });\n  }\n}\n\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = '';\n    });\n  }\n}\n\nexport function normalizeAnimationEntry(steps: AnimationMetadata | AnimationMetadata[]):\n    AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return steps as AnimationMetadata;\n}\n\nexport function validateStyleParams(\n    value: string | number, options: AnimationOptions, errors: any[]) {\n  const params = options.params || {};\n  const matches = extractStyleParams(value);\n  if (matches.length) {\n    matches.forEach(varName => {\n      if (!params.hasOwnProperty(varName)) {\n        errors.push(\n            `Unable to resolve the local animation param ${varName} in the given list of values`);\n      }\n    });\n  }\n}\n\nconst PARAM_REGEX =\n    new RegExp(`${SUBSTITUTION_EXPR_START}\\\\s*(.+?)\\\\s*${SUBSTITUTION_EXPR_END}`, 'g');\nexport function extractStyleParams(value: string | number): string[] {\n  let params: string[] = [];\n  if (typeof value === 'string') {\n    const val = value.toString();\n\n    let match: any;\n    while (match = PARAM_REGEX.exec(val)) {\n      params.push(match[1] as string);\n    }\n    PARAM_REGEX.lastIndex = 0;\n  }\n  return params;\n}\n\nexport function interpolateParams(\n    value: string | number, params: {[name: string]: any}, errors: any[]): string|number {\n  const original = value.toString();\n  const str = original.replace(PARAM_REGEX, (_, varName) => {\n    let localVal = params[varName];\n    // this means that the value was never overidden by the data passed in by the user\n    if (!params.hasOwnProperty(varName)) {\n      errors.push(`Please provide a value for the animation param ${varName}`);\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n\n  // we do this to assert that numeric values stay as they are\n  return str == original ? value : str;\n}\n\nexport function iteratorToArray(iterator: any): any[] {\n  const arr: any[] = [];\n  let item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n\nexport function mergeAnimationOptions(\n    source: AnimationOptions, destination: AnimationOptions): AnimationOptions {\n  if (source.params) {\n    const p0 = source.params;\n    if (!destination.params) {\n      destination.params = {};\n    }\n    const p1 = destination.params;\n    Object.keys(p0).forEach(param => {\n      if (!p1.hasOwnProperty(param)) {\n        p1[param] = p0[param];\n      }\n    });\n  }\n  return destination;\n}\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function allowPreviousPlayerStylesMerge(duration: number, delay: number) {\n  return duration === 0 || delay === 0;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData = {},\n    postStyles: ɵStyleData = {}): ɵStyleData[] {\n  const errors: string[] = [];\n  const normalizedKeyframes: ɵStyleData[] = [];\n  let previousOffset = -1;\n  let previousKeyframe: ɵStyleData|null = null;\n  keyframes.forEach(kf => {\n    const offset = kf['offset'] as number;\n    const isSameOffset = offset == previousOffset;\n    const normalizedKeyframe: ɵStyleData = (isSameOffset && previousKeyframe) || {};\n    Object.keys(kf).forEach(prop => {\n      let normalizedProp = prop;\n      let normalizedValue = kf[prop];\n      if (prop !== 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n        switch (normalizedValue) {\n          case PRE_STYLE:\n            normalizedValue = preStyles[prop];\n            break;\n\n          case AUTO_STYLE:\n            normalizedValue = postStyles[prop];\n            break;\n\n          default:\n            normalizedValue =\n                normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n            break;\n        }\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player.totalTime)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player.totalTime)));\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)));\n      break;\n  }\n}\n\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  const event = makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n  const data = (e as any)['_data'];\n  if (data != null) {\n    (event as any)['_data'] = data;\n  }\n  return event;\n}\n\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n\nexport function parseTimelineCommand(command: string): [string, string] {\n  const separatorPos = command.indexOf(':');\n  const id = command.substring(1, separatorPos);\n  const action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n\nlet _contains: (elm1: any, elm2: any) => boolean = (elm1: any, elm2: any) => false;\nlet _matches: (element: any, selector: string) => boolean = (element: any, selector: string) =>\n    false;\nlet _query: (element: any, selector: string, multi: boolean) => any[] =\n    (element: any, selector: string, multi: boolean) => {\n      return [];\n    };\n\nif (typeof Element != 'undefined') {\n  // this is well supported in all browsers\n  _contains = (elm1: any, elm2: any) => { return elm1.contains(elm2) as boolean; };\n\n  if (Element.prototype.matches) {\n    _matches = (element: any, selector: string) => element.matches(selector);\n  } else {\n    const proto = Element.prototype as any;\n    const fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n        proto.oMatchesSelector || proto.webkitMatchesSelector;\n    if (fn) {\n      _matches = (element: any, selector: string) => fn.apply(element, [selector]);\n    }\n  }\n\n  _query = (element: any, selector: string, multi: boolean): any[] => {\n    let results: any[] = [];\n    if (multi) {\n      results.push(...element.querySelectorAll(selector));\n    } else {\n      const elm = element.querySelector(selector);\n      if (elm) {\n        results.push(elm);\n      }\n    }\n    return results;\n  };\n}\n\nexport const matchesElement = _matches;\nexport const containsElement = _contains;\nexport const invokeQuery = _query;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {scheduleMicroTask} from '../util';\nimport {AnimationPlayer} from './animation_player';\nexport class AnimationGroupPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _finished = false;\nprivate _started = false;\nprivate _destroyed = false;\nprivate _onDestroyFns: Function[] = [];\npublic parentPlayer: AnimationPlayer|null = null;\npublic totalTime: number = 0;\n/**\n * @param {?} _players\n */\nconstructor(private _players: AnimationPlayer[]) {\n    let doneCount = 0;\n    let destroyCount = 0;\n    let startCount = 0;\n    const total = this._players.length;\n\n    if (total == 0) {\n      scheduleMicroTask(() => this._onFinish());\n    } else {\n      this._players.forEach(player => {\n        player.parentPlayer = this;\n        player.onDone(() => {\n          if (++doneCount >= total) {\n            this._onFinish();\n          }\n        });\n        player.onDestroy(() => {\n          if (++destroyCount >= total) {\n            this._onDestroy();\n          }\n        });\n        player.onStart(() => {\n          if (++startCount >= total) {\n            this._onStart();\n          }\n        });\n      });\n    }\n\n    this.totalTime = this._players.reduce((time, player) => Math.max(time, player.totalTime), 0);\n  }\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @return {?}\n */\ninit(): void { this._players.forEach(player => player.init()); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @return {?}\n */\nprivate _onStart() {\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n    }\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nhasStarted() { return this._started; }\n/**\n * @return {?}\n */\nplay() {\n    if (!this.parentPlayer) {\n      this.init();\n    }\n    this._onStart();\n    this._players.forEach(player => player.play());\n  }\n/**\n * @return {?}\n */\npause(): void { this._players.forEach(player => player.pause()); }\n/**\n * @return {?}\n */\nrestart(): void { this._players.forEach(player => player.restart()); }\n/**\n * @return {?}\n */\nfinish(): void {\n    this._onFinish();\n    this._players.forEach(player => player.finish());\n  }\n/**\n * @return {?}\n */\ndestroy(): void { this._onDestroy(); }\n/**\n * @return {?}\n */\nprivate _onDestroy() {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this._onFinish();\n      this._players.forEach(player => player.destroy());\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @return {?}\n */\nreset(): void {\n    this._players.forEach(player => player.reset());\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void {\n    const /** @type {?} */ timeAtPosition = p * this.totalTime;\n    this._players.forEach(player => {\n      const /** @type {?} */ position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\n      player.setPosition(position);\n    });\n  }\n/**\n * @return {?}\n */\ngetPosition(): number {\n    let /** @type {?} */ min = 0;\n    this._players.forEach(player => {\n      const /** @type {?} */ p = player.getPosition();\n      min = Math.min(p, min);\n    });\n    return min;\n  }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] { return this._players; }\n/**\n * @return {?}\n */\nbeforeDestroy(): void {\n    this.players.forEach(player => {\n      if (player.beforeDestroy) {\n        player.beforeDestroy();\n      }\n    });\n  }\n}\n\nfunction AnimationGroupPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationGroupPlayer.prototype._onDoneFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype._onStartFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype._finished;\n/** @type {?} */\nAnimationGroupPlayer.prototype._started;\n/** @type {?} */\nAnimationGroupPlayer.prototype._destroyed;\n/** @type {?} */\nAnimationGroupPlayer.prototype._onDestroyFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype.parentPlayer;\n/** @type {?} */\nAnimationGroupPlayer.prototype.totalTime;\n/** @type {?} */\nAnimationGroupPlayer.prototype._players;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {AnimationGroupPlayer as ɵAnimationGroupPlayer} from './players/animation_group_player';\nexport const /** @type {?} */ ɵPRE_STYLE = '!';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {scheduleMicroTask} from '../util';\n\n/**\n * AnimationPlayer controls an animation sequence that was produced from a programmatic animation.\n * (see {@link AnimationBuilder AnimationBuilder} for more information on how to create programmatic\n * animations.)\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationPlayer {\n  onDone(fn: () => void): void;\n  onStart(fn: () => void): void;\n  onDestroy(fn: () => void): void;\n  init(): void;\n  hasStarted(): boolean;\n  play(): void;\n  pause(): void;\n  restart(): void;\n  finish(): void;\n  destroy(): void;\n  reset(): void;\n  setPosition(p: any /** TODO #9100 */): void;\n  getPosition(): number;\n  parentPlayer: AnimationPlayer|null;\n  readonly totalTime: number;\n  beforeDestroy?: () => any;\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class NoopAnimationPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _onDestroyFns: Function[] = [];\nprivate _started = false;\nprivate _destroyed = false;\nprivate _finished = false;\npublic parentPlayer: AnimationPlayer|null = null;\npublic totalTime = 0;\nconstructor() {}\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this._started; }\n/**\n * @return {?}\n */\ninit(): void {}\n/**\n * @return {?}\n */\nplay(): void {\n    if (!this.hasStarted()) {\n      this.triggerMicrotask();\n      this._onStart();\n    }\n    this._started = true;\n  }\n/**\n * @return {?}\n */\ntriggerMicrotask() { scheduleMicroTask(() => this._onFinish()); }\n/**\n * @return {?}\n */\nprivate _onStart() {\n    this._onStartFns.forEach(fn => fn());\n    this._onStartFns = [];\n  }\n/**\n * @return {?}\n */\npause(): void {}\n/**\n * @return {?}\n */\nrestart(): void {}\n/**\n * @return {?}\n */\nfinish(): void { this._onFinish(); }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      if (!this.hasStarted()) {\n        this._onStart();\n      }\n      this.finish();\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @return {?}\n */\nreset(): void {}\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void {}\n/**\n * @return {?}\n */\ngetPosition(): number { return 0; }\n}\n\nfunction NoopAnimationPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopAnimationPlayer.prototype._onDoneFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._onStartFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._onDestroyFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._started;\n/** @type {?} */\nNoopAnimationPlayer.prototype._destroyed;\n/** @type {?} */\nNoopAnimationPlayer.prototype._finished;\n/** @type {?} */\nNoopAnimationPlayer.prototype.parentPlayer;\n/** @type {?} */\nNoopAnimationPlayer.prototype.totalTime;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport interface ɵStyleData { [key: string]: string|number; }\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are created internally\n * within the Angular animation DSL.\n *\n * @experimental Animation support is experimental.\n */\nexport declare type AnimateTimings = {\n  duration: number,\n  delay: number,\n  easing: string | null\n};\n\n/**\n * `AnimationOptions` represents options that can be passed into most animation DSL methods.\n * When options are provided, the delay value of an animation can be changed and animation input\n * parameters can be passed in to change styling and timing data when an animation is started.\n *\n * The following animation DSL functions are able to accept animation option data:\n *\n * - {@link transition transition()}\n * - {@link sequence sequence()}\n * - {@link group group()}\n * - {@link query query()}\n * - {@link animation animation()}\n * - {@link useAnimation useAnimation()}\n * - {@link animateChild animateChild()}\n *\n * Programmatic animations built using {@link AnimationBuilder the AnimationBuilder service} also\n * make use of AnimationOptions.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimationOptions {\n  delay?: number|string;\n  params?: {[name: string]: any};\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are created internally\n * within the Angular animation DSL when {@link animateChild animateChild()} is used.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimateChildOptions extends AnimationOptions { duration?: number|string; }\n\n/**\n * Metadata representing the entry of animations. Usages of this enum are created\n * each time an animation DSL function is used.\n *\n * @experimental Animation support is experimental.\n */\nexport const enum AnimationMetadataType {\n  State = 0,\n  Transition = 1,\n  Sequence = 2,\n  Group = 3,\n  Animate = 4,\n  Keyframes = 5,\n  Style = 6,\n  Trigger = 7,\n  Reference = 8,\n  AnimateChild = 9,\n  AnimateRef = 10,\n  Query = 11,\n  Stagger = 12\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport const AUTO_STYLE = '*';\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationMetadata { type: AnimationMetadataType; }\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link trigger trigger animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationTriggerMetadata extends AnimationMetadata {\n  name: string;\n  definitions: AnimationMetadata[];\n  options: {params?: {[name: string]: any}}|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link state state animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationStateMetadata extends AnimationMetadata {\n  name: string;\n  styles: AnimationStyleMetadata;\n  options?: {params: {[name: string]: any}};\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link transition transition animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationTransitionMetadata extends AnimationMetadata {\n  expr: string;\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationReferenceMetadata extends AnimationMetadata {\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport interface AnimationQueryMetadata extends AnimationMetadata {\n  selector: string;\n  animation: AnimationMetadata|AnimationMetadata[];\n  options: AnimationQueryOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link keyframes keyframes animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {\n  steps: AnimationStyleMetadata[];\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link style style animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationStyleMetadata extends AnimationMetadata {\n  styles: '*'|{[key: string]: string | number}|Array<{[key: string]: string | number}|'*'>;\n  offset: number|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link animate animate animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateMetadata extends AnimationMetadata {\n  timings: string|number|AnimateTimings;\n  styles: AnimationStyleMetadata|AnimationKeyframesSequenceMetadata|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link animateChild animateChild animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateChildMetadata extends AnimationMetadata {\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link useAnimation useAnimation animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationAnimateRefMetadata extends AnimationMetadata {\n  animation: AnimationReferenceMetadata;\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link sequence sequence animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationSequenceMetadata extends AnimationMetadata {\n  steps: AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link group group animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationGroupMetadata extends AnimationMetadata {\n  steps: AnimationMetadata[];\n  options: AnimationOptions|null;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link query query animation function} is called.\n *\n * @experimental Animation support is experimental.\n */\nexport declare interface AnimationQueryOptions extends AnimationOptions {\n  optional?: boolean;\n  limit?: number;\n}\n\n/**\n * Metadata representing the entry of animations. Instances of this interface are provided via the\n * animation DSL when the {@link stagger stagger animation function} is called.\n *\n* @experimental Animation support is experimental.\n*/\nexport interface AnimationStaggerMetadata extends AnimationMetadata {\n  timings: string|number;\n  animation: AnimationMetadata|AnimationMetadata[];\n}\n/**\n * `trigger` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the\n * {\\@link Component#animations component animations metadata page} to gain a better\n * understanding of how animations in Angular are used.\n * \n * `trigger` Creates an animation trigger which will a list of {\\@link state state} and\n * {\\@link transition transition} entries that will be evaluated when the expression\n * bound to the trigger changes.\n * \n * Triggers are registered within the component annotation data under the\n * {\\@link Component#animations animations section}. An animation trigger can be placed on an element\n * within a template by referencing the name of the trigger followed by the expression value that\n * the\n * trigger is bound to (in the form of `[\\@triggerName]=\"expression\"`.\n * \n * ### Usage\n * \n * `trigger` will create an animation trigger reference based on the provided `name` value. The\n * provided `animation` value is expected to be an array consisting of {\\@link state state} and\n * {\\@link transition transition} declarations.\n * \n * ```typescript\n * \\@Component({ \n *   selector: 'my-component',\n *   templateUrl: 'my-component-tpl.html',\n *   animations: [\n *     trigger(\"myAnimationTrigger\", [\n *       state(...),\n *       state(...),\n *       transition(...),\n *       transition(...)\n *     ])\n *   ]\n * })\n * class MyComponent {\n *   myStatusExp = \"something\";\n * }\n * ```\n * \n * The template associated with this component will make use of the `myAnimationTrigger` animation\n * trigger by binding to an element within its template code.\n * \n * ```html\n * <!-- somewhere inside of my-component-tpl.html -->\n * <div [\\@myAnimationTrigger]=\"myStatusExp\">...</div>\n * ```\n * \n * ## Disable Animations\n * A special animation control binding called `\\@.disabled` can be placed on an element which will\n * then disable animations for any inner animation triggers situated within the element as well as\n * any animations on the element itself.\n * \n * When true, the `\\@.disabled` binding will prevent all animations from rendering. The example\n * below shows how to use this feature:\n * \n * ```ts\n * \\@Component({ \n *   selector: 'my-component',\n *   template: `\n *     <div [\\@.disabled]=\"isDisabled\">\n *       <div [\\@childAnimation]=\"exp\"></div>\n *     </div>\n *   `,\n *   animations: [\n *     trigger(\"childAnimation\", [\n *       // ...\n *     ])\n *   ]\n * })\n * class MyComponent {\n *   isDisabled = true;\n *   exp = '...';\n * }\n * ```\n * \n * The `\\@childAnimation` trigger will not animate because `\\@.disabled` prevents it from happening\n * (when true).\n * \n * Note that `\\@.disbled` will only disable all animations (this means any animations running on\n * the same element will also be disabled).\n * \n * ### Disabling Animations Application-wide\n * When an area of the template is set to have animations disabled, **all** inner components will\n * also have their animations disabled as well. This means that all animations for an angular\n * application can be disabled by placing a host binding set on `\\@.disabled` on the topmost Angular\n * component.\n * \n * ```ts\n * import {Component, HostBinding} from '\\@angular/core';\n * \n * \\@Component({ \n *   selector: 'app-component',\n *   templateUrl: 'app.component.html',\n * })\n * class AppComponent {\n *   \\@HostBinding('\\@.disabled')\n *   public animationsDisabled = true;\n * }\n * ```\n * \n * ### What about animations that us `query()` and `animateChild()`?\n * Despite inner animations being disabled, a parent animation can {\\@link query query} for inner\n * elements located in disabled areas of the template and still animate them as it sees fit. This is\n * also the case for when a sub animation is queried by a parent and then later animated using {\\@link\n * animateChild animateChild}.\n * \n * \\@experimental Animation support is experimental.\n * @param {?} name\n * @param {?} definitions\n * @return {?}\n */\nexport function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata {\n  return {type: AnimationMetadataType.Trigger, name, definitions, options: {}};\n}\n/**\n * `animate` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `animate` specifies an animation step that will apply the provided `styles` data for a given\n * amount of time based on the provided `timing` expression value. Calls to `animate` are expected\n * to be used within {\\@link sequence an animation sequence}, {\\@link group group}, or {\\@link\n * transition transition}.\n * \n * ### Usage\n * \n * The `animate` function accepts two input parameters: `timing` and `styles`:\n * \n * - `timing` is a string based value that can be a combination of a duration with optional delay\n * and easing values. The format for the expression breaks down to `duration delay easing`\n * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,\n * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the\n * `duration` value in millisecond form.\n * - `styles` is the style input data which can either be a call to {\\@link style style} or {\\@link\n * keyframes keyframes}. If left empty then the styles from the destination state will be collected\n * and used (this is useful when describing an animation step that will complete an animation by\n * {\\@link transition#the-final-animate-call animating to the final state}).\n * \n * ```typescript\n * // various functions for specifying timing data\n * animate(500, style(...))\n * animate(\"1s\", style(...))\n * animate(\"100ms 0.5s\", style(...))\n * animate(\"5s ease\", style(...))\n * animate(\"5s 10ms cubic-bezier(.17,.67,.88,.1)\", style(...))\n * \n * // either style() of keyframes() can be used\n * animate(500, style({ background: \"red\" }))\n * animate(500, keyframes([\n *   style({ background: \"blue\" })),\n *   style({ background: \"red\" }))\n * ])\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} timings\n * @param {?=} styles\n * @return {?}\n */\nexport function animate(\n    timings: string | number, styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata |\n        null = null): AnimationAnimateMetadata {\n  return {type: AnimationMetadataType.Animate, styles, timings};\n}\n/**\n * `group` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are\n * useful when a series of styles must be animated/closed off at different starting/ending times.\n * \n * The `group` function can either be used within a {\\@link sequence sequence} or a {\\@link transition\n * transition} and it will only continue to the next instruction once all of the inner animation\n * steps have completed.\n * \n * ### Usage\n * \n * The `steps` data that is passed into the `group` animation function can either consist of {\\@link\n * style style} or {\\@link animate animate} function calls. Each call to `style()` or `animate()`\n * within a group will be executed instantly (use {\\@link keyframes keyframes} or a {\\@link\n * animate#usage animate() with a delay value} to offset styles to be applied at a later time).\n * \n * ```typescript\n * group([\n *   animate(\"1s\", { background: \"black\" }))\n *   animate(\"2s\", { color: \"white\" }))\n * ])\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} steps\n * @param {?=} options\n * @return {?}\n */\nexport function group(\n    steps: AnimationMetadata[], options: AnimationOptions | null = null): AnimationGroupMetadata {\n  return {type: AnimationMetadataType.Group, steps, options};\n}\n/**\n * `sequence` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by\n * default when an array is passed as animation data into {\\@link transition transition}.)\n * \n * The `sequence` function can either be used within a {\\@link group group} or a {\\@link transition\n * transition} and it will only continue to the next instruction once each of the inner animation\n * steps have completed.\n * \n * To perform animation styling in parallel with other animation steps then have a look at the\n * {\\@link group group} animation function.\n * \n * ### Usage\n * \n * The `steps` data that is passed into the `sequence` animation function can either consist of\n * {\\@link style style} or {\\@link animate animate} function calls. A call to `style()` will apply the\n * provided styling data immediately while a call to `animate()` will apply its styling data over a\n * given time depending on its timing data.\n * \n * ```typescript\n * sequence([\n *   style({ opacity: 0 })),\n *   animate(\"1s\", { opacity: 1 }))\n * ])\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} steps\n * @param {?=} options\n * @return {?}\n */\nexport function sequence(steps: AnimationMetadata[], options: AnimationOptions | null = null):\n    AnimationSequenceMetadata {\n  return {type: AnimationMetadataType.Sequence, steps, options};\n}\n/**\n * `style` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `style` declares a key/value object containing CSS properties/styles that can then be used for\n * {\\@link state animation states}, within an {\\@link sequence animation sequence}, or as styling data\n * for both {\\@link animate animate} and {\\@link keyframes keyframes}.\n * \n * ### Usage\n * \n * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs\n * to be defined.\n * \n * ```typescript\n * // string values are used for css properties\n * style({ background: \"red\", color: \"blue\" })\n * \n * // numerical (pixel) values are also supported\n * style({ width: 100, height: 0 })\n * ```\n * \n * #### Auto-styles (using `*`)\n * \n * When an asterix (`*`) character is used as a value then it will be detected from the element\n * being animated and applied as animation data when the animation starts.\n * \n * This feature proves useful for a state depending on layout and/or environment factors; in such\n * cases the styles are calculated just before the animation starts.\n * \n * ```typescript\n * // the steps below will animate from 0 to the\n * // actual height of the element\n * style({ height: 0 }),\n * animate(\"1s\", style({ height: \"*\" }))\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} tokens\n * @return {?}\n */\nexport function style(\n    tokens: '*' | {[key: string]: string | number} |\n    Array<'*'|{[key: string]: string | number}>): AnimationStyleMetadata {\n  return {type: AnimationMetadataType.Style, styles: tokens, offset: null};\n}\n/**\n * `state` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `state` declares an animation state within the given trigger. When a state is active within a\n * component then its associated styles will persist on the element that the trigger is attached to\n * (even when the animation ends).\n * \n * To animate between states, have a look at the animation {\\@link transition transition} DSL\n * function. To register states to an animation trigger please have a look at the {\\@link trigger\n * trigger} function.\n * \n * #### The `void` state\n * \n * The `void` state value is a reserved word that angular uses to determine when the element is not\n * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the\n * associated element is void).\n * \n * #### The `*` (default) state\n * \n * The `*` state (when styled) is a fallback state that will be used if the state that is being\n * animated is not declared within the trigger.\n * \n * ### Usage\n * \n * `state` will declare an animation state with its associated styles\n * within the given trigger.\n * \n * - `stateNameExpr` can be one or more state names separated by commas.\n * - `styles` refers to the {\\@link style styling data} that will be persisted on the element once\n * the state has been reached.\n * \n * ```typescript\n * // \"void\" is a reserved name for a state and is used to represent\n * // the state in which an element is detached from from the application.\n * state(\"void\", style({ height: 0 }))\n * \n * // user-defined states\n * state(\"closed\", style({ height: 0 }))\n * state(\"open, visible\", style({ height: \"*\" }))\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} name\n * @param {?} styles\n * @param {?=} options\n * @return {?}\n */\nexport function state(\n    name: string, styles: AnimationStyleMetadata,\n    options?: {params: {[name: string]: any}}): AnimationStateMetadata {\n  return {type: AnimationMetadataType.State, name, styles, options};\n}\n/**\n * `keyframes` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `keyframes` specifies a collection of {\\@link style style} entries each optionally characterized\n * by an `offset` value.\n * \n * ### Usage\n * \n * The `keyframes` animation function is designed to be used alongside the {\\@link animate animate}\n * animation function. Instead of applying animations from where they are currently to their\n * destination, keyframes can describe how each style entry is applied and at what point within the\n * animation arc (much like CSS Keyframe Animations do).\n * \n * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what\n * percentage of the animate time the styles will be applied.\n * \n * ```typescript\n * // the provided offset values describe when each backgroundColor value is applied.\n * animate(\"5s\", keyframes([\n *   style({ backgroundColor: \"red\", offset: 0 }),\n *   style({ backgroundColor: \"blue\", offset: 0.2 }),\n *   style({ backgroundColor: \"orange\", offset: 0.3 }),\n *   style({ backgroundColor: \"black\", offset: 1 })\n * ]))\n * ```\n * \n * Alternatively, if there are no `offset` values used within the style entries then the offsets\n * will be calculated automatically.\n * \n * ```typescript\n * animate(\"5s\", keyframes([\n *   style({ backgroundColor: \"red\" }) // offset = 0\n *   style({ backgroundColor: \"blue\" }) // offset = 0.33\n *   style({ backgroundColor: \"orange\" }) // offset = 0.66\n *   style({ backgroundColor: \"black\" }) // offset = 1\n * ]))\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} steps\n * @return {?}\n */\nexport function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata {\n  return {type: AnimationMetadataType.Keyframes, steps};\n}\n/**\n * `transition` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. If this information is new, please navigate to the {\\@link\n * Component#animations component animations metadata page} to gain a better understanding of\n * how animations in Angular are used.\n * \n * `transition` declares the {\\@link sequence sequence of animation steps} that will be run when the\n * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>\n * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting\n * and/or ending state).\n * \n * A function can also be provided as the `stateChangeExpr` argument for a transition and this\n * function will be executed each time a state change occurs. If the value returned within the\n * function is true then the associated animation will be run.\n * \n * Animation transitions are placed within an {\\@link trigger animation trigger}. For an transition\n * to animate to a state value and persist its styles then one or more {\\@link state animation\n * states} is expected to be defined.\n * \n * ### Usage\n * \n * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on\n * what the previous state is and what the current state has become. In other words, if a transition\n * is defined that matches the old/current state criteria then the associated animation will be\n * triggered.\n * \n * ```typescript\n * // all transition/state changes are defined within an animation trigger\n * trigger(\"myAnimationTrigger\", [\n *   // if a state is defined then its styles will be persisted when the\n *   // animation has fully completed itself\n *   state(\"on\", style({ background: \"green\" })),\n *   state(\"off\", style({ background: \"grey\" })),\n * \n *   // a transition animation that will be kicked off when the state value\n *   // bound to \"myAnimationTrigger\" changes from \"on\" to \"off\"\n *   transition(\"on => off\", animate(500)),\n * \n *   // it is also possible to do run the same animation for both directions\n *   transition(\"on <=> off\", animate(500)),\n * \n *   // or to define multiple states pairs separated by commas\n *   transition(\"on => off, off => void\", animate(500)),\n * \n *   // this is a catch-all state change for when an element is inserted into\n *   // the page and the destination state is unknown\n *   transition(\"void => *\", [\n *     style({ opacity: 0 }),\n *     animate(500)\n *   ]),\n * \n *   // this will capture a state change between any states\n *   transition(\"* => *\", animate(\"1s 0s\")),\n * \n *   // you can also go full out and include a function\n *   transition((fromState, toState) => {\n *     // when `true` then it will allow the animation below to be invoked\n *     return fromState == \"off\" && toState == \"on\";\n *   }, animate(\"1s 0s\"))\n * ])\n * ```\n * \n * The template associated with this component will make use of the `myAnimationTrigger` animation\n * trigger by binding to an element within its template code.\n * \n * ```html\n * <!-- somewhere inside of my-component-tpl.html -->\n * <div [\\@myAnimationTrigger]=\"myStatusExp\">...</div>\n * ```\n * \n * #### The final `animate` call\n * \n * If the final step within the transition steps is a call to `animate()` that **only** uses a\n * timing value with **no style data** then it will be automatically used as the final animation arc\n * for the element to animate itself to the final state. This involves an automatic mix of\n * adding/removing CSS styles so that the element will be in the exact state it should be for the\n * applied state to be presented correctly.\n * \n * ```\n * // start off by hiding the element, but make sure that it animates properly to whatever state\n * // is currently active for \"myAnimationTrigger\"\n * transition(\"void => *\", [\n *   style({ opacity: 0 }),\n *   animate(500)\n * ])\n * ```\n * \n * ### Transition Aliases (`:enter` and `:leave`)\n * \n * Given that enter (insertion) and leave (removal) animations are so common, the `transition`\n * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*\n * => void` state changes.\n * \n * ```\n * transition(\":enter\", [\n *   style({ opacity: 0 }),\n *   animate(500, style({ opacity: 1 }))\n * ])\n * transition(\":leave\", [\n *   animate(500, style({ opacity: 0 }))\n * ])\n * ```\n * \n * {\\@example core/animation/ts/dsl/animation_example.ts region='Component'}\n * \n * \\@experimental Animation support is experimental.\n * @param {?} stateChangeExpr\n * @param {?} steps\n * @param {?=} options\n * @return {?}\n */\nexport function transition(\n    stateChangeExpr: string, steps: AnimationMetadata | AnimationMetadata[],\n    options: AnimationOptions | null = null): AnimationTransitionMetadata {\n  return {type: AnimationMetadataType.Transition, expr: stateChangeExpr, animation: steps, options};\n}\n/**\n * `animation` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language.\n * \n * `var myAnimation = animation(...)` is designed to produce a reusable animation that can be later\n * invoked in another animation or sequence. Reusable animations are designed to make use of\n * animation parameters and the produced animation can be used via the `useAnimation` method.\n * \n * ```\n * var fadeAnimation = animation([\n *   style({ opacity: '{{ start }}' }),\n *   animate('{{ time }}',\n *     style({ opacity: '{{ end }}'))\n * ], { params: { time: '1000ms', start: 0, end: 1 }});\n * ```\n * \n * If parameters are attached to an animation then they act as **default parameter values**. When an\n * animation is invoked via `useAnimation` then parameter values are allowed to be passed in\n * directly. If any of the passed in parameter values are missing then the default values will be\n * used.\n * \n * ```\n * useAnimation(fadeAnimation, {\n *   params: {\n *     time: '2s',\n *     start: 1,\n *     end: 0\n *   }\n * })\n * ```\n * \n * If one or more parameter values are missing before animated then an error will be thrown.\n * \n * \\@experimental Animation support is experimental.\n * @param {?} steps\n * @param {?=} options\n * @return {?}\n */\nexport function animation(\n    steps: AnimationMetadata | AnimationMetadata[],\n    options: AnimationOptions | null = null): AnimationReferenceMetadata {\n  return {type: AnimationMetadataType.Reference, animation: steps, options};\n}\n/**\n * `animateChild` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It works by allowing a queried element to execute its own\n * animation within the animation sequence.\n * \n * Each time an animation is triggered in angular, the parent animation\n * will always get priority and any child animations will be blocked. In order\n * for a child animation to run, the parent animation must query each of the elements\n * containing child animations and then allow the animations to run using `animateChild`.\n * \n * The example HTML code below shows both parent and child elements that have animation\n * triggers that will execute at the same time.\n * \n * ```html\n * <!-- parent-child.component.html -->\n * <button (click)=\"exp =! exp\">Toggle</button>\n * <hr>\n * \n * <div [\\@parentAnimation]=\"exp\">\n *   <header>Hello</header>\n *   <div [\\@childAnimation]=\"exp\">\n *       one\n *   </div>\n *   <div [\\@childAnimation]=\"exp\">\n *       two\n *   </div>\n *   <div [\\@childAnimation]=\"exp\">\n *       three\n *   </div>\n * </div>\n * ```\n * \n * Now when the `exp` value changes to true, only the `parentAnimation` animation will animate\n * because it has priority. However, using `query` and `animateChild` each of the inner animations\n * can also fire:\n * \n * ```ts\n * // parent-child.component.ts\n * import {trigger, transition, animate, style, query, animateChild} from '\\@angular/animations';\n * \\@Component({ \n *   selector: 'parent-child-component',\n *   animations: [\n *     trigger('parentAnimation', [\n *       transition('false => true', [\n *         query('header', [\n *           style({ opacity: 0 }),\n *           animate(500, style({ opacity: 1 }))\n *         ]),\n *         query('\\@childAnimation', [\n *           animateChild()\n *         ])\n *       ])\n *     ]),\n *     trigger('childAnimation', [\n *       transition('false => true', [\n *         style({ opacity: 0 }),\n *         animate(500, style({ opacity: 1 }))\n *       ])\n *     ])\n *   ]\n * })\n * class ParentChildCmp {\n *   exp: boolean = false;\n * }\n * ```\n * \n * In the animation code above, when the `parentAnimation` transition kicks off it first queries to\n * find the header element and fades it in. It then finds each of the sub elements that contain the\n * `\\@childAnimation` trigger and then allows for their animations to fire.\n * \n * This example can be further extended by using stagger:\n * \n * ```ts\n * query('\\@childAnimation', stagger(100, [\n *   animateChild()\n * ]))\n * ```\n * \n * Now each of the sub animations start off with respect to the `100ms` staggering step.\n * \n * ## The first frame of child animations\n * When sub animations are executed using `animateChild` the animation engine will always apply the\n * first frame of every sub animation immediately at the start of the animation sequence. This way\n * the parent animation does not need to set any initial styling data on the sub elements before the\n * sub animations kick off.\n * \n * In the example above the first frame of the `childAnimation`'s `false => true` transition\n * consists of a style of `opacity: 0`. This is applied immediately when the `parentAnimation`\n * animation transition sequence starts. Only then when the `\\@childAnimation` is queried and called\n * with `animateChild` will it then animate to its destination of `opacity: 1`.\n * \n * Note that this feature designed to be used alongside {\\@link query query()} and it will only work\n * with animations that are assigned using the Angular animation DSL (this means that CSS keyframes\n * and transitions are not handled by this API).\n * \n * \\@experimental Animation support is experimental.\n * @param {?=} options\n * @return {?}\n */\nexport function animateChild(options: AnimateChildOptions | null = null):\n    AnimationAnimateChildMetadata {\n  return {type: AnimationMetadataType.AnimateChild, options};\n}\n/**\n * `useAnimation` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It is used to kick off a reusable animation that is created using {\\@link\n * animation animation()}.\n * \n * \\@experimental Animation support is experimental.\n * @param {?} animation\n * @param {?=} options\n * @return {?}\n */\nexport function useAnimation(\n    animation: AnimationReferenceMetadata,\n    options: AnimationOptions | null = null): AnimationAnimateRefMetadata {\n  return {type: AnimationMetadataType.AnimateRef, animation, options};\n}\n/**\n * `query` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language.\n * \n * query() is used to find one or more inner elements within the current element that is\n * being animated within the sequence. The provided animation steps are applied\n * to the queried element (by default, an array is provided, then this will be\n * treated as an animation sequence).\n * \n * ### Usage\n * \n * query() is designed to collect mutiple elements and works internally by using\n * `element.querySelectorAll`. An additional options object can be provided which\n * can be used to limit the total amount of items to be collected.\n * \n * ```js\n * query('div', [\n *   animate(...),\n *   animate(...)\n * ], { limit: 1 })\n * ```\n * \n * query(), by default, will throw an error when zero items are found. If a query\n * has the `optional` flag set to true then this error will be ignored.\n * \n * ```js\n * query('.some-element-that-may-not-be-there', [\n *   animate(...),\n *   animate(...)\n * ], { optional: true })\n * ```\n * \n * ### Special Selector Values\n * \n * The selector value within a query can collect elements that contain angular-specific\n * characteristics\n * using special pseudo-selectors tokens.\n * \n * These include:\n * \n *  - Querying for newly inserted/removed elements using `query(\":enter\")`/`query(\":leave\")`\n *  - Querying all currently animating elements using `query(\":animating\")`\n *  - Querying elements that contain an animation trigger using `query(\"\\@triggerName\")`\n *  - Querying all elements that contain an animation triggers using `query(\"\\@*\")`\n *  - Including the current element into the animation sequence using `query(\":self\")`\n * \n * \n *  Each of these pseudo-selector tokens can be merged together into a combined query selector\n * string:\n * \n *  ```\n *  query(':self, .record:enter, .record:leave, \\@subTrigger', [...])\n *  ```\n * \n * ### Demo\n * \n * ```\n * \\@Component({ \n *   selector: 'inner',\n *   template: `\n *     <div [\\@queryAnimation]=\"exp\">\n *       <h1>Title</h1>\n *       <div class=\"content\">\n *         Blah blah blah\n *       </div>\n *     </div>\n *   `,\n *   animations: [\n *    trigger('queryAnimation', [\n *      transition('* => goAnimate', [\n *        // hide the inner elements\n *        query('h1', style({ opacity: 0 })),\n *        query('.content', style({ opacity: 0 })),\n * \n *        // animate the inner elements in, one by one\n *        query('h1', animate(1000, style({ opacity: 1 })),\n *        query('.content', animate(1000, style({ opacity: 1 })),\n *      ])\n *    ])\n *  ]\n * })\n * class Cmp {\n *   exp = '';\n * \n *   goAnimate() {\n *     this.exp = 'goAnimate';\n *   }\n * }\n * ```\n * \n * \\@experimental Animation support is experimental.\n * @param {?} selector\n * @param {?} animation\n * @param {?=} options\n * @return {?}\n */\nexport function query(\n    selector: string, animation: AnimationMetadata | AnimationMetadata[],\n    options: AnimationQueryOptions | null = null): AnimationQueryMetadata {\n  return {type: AnimationMetadataType.Query, selector, animation, options};\n}\n/**\n * `stagger` is an animation-specific function that is designed to be used inside of Angular's\n * animation DSL language. It is designed to be used inside of an animation {\\@link query query()}\n * and works by issuing a timing gap between after each queried item is animated.\n * \n * ### Usage\n * \n * In the example below there is a container element that wraps a list of items stamped out\n * by an ngFor. The container element contains an animation trigger that will later be set\n * to query for each of the inner items.\n * \n * ```html\n * <!-- list.component.html -->\n * <button (click)=\"toggle()\">Show / Hide Items</button>\n * <hr />\n * <div [\\@listAnimation]=\"items.length\">\n *   <div *ngFor=\"let item of items\">\n *     {{ item }}\n *   </div>\n * </div>\n * ```\n * \n * The component code for this looks as such:\n * \n * ```ts\n * import {trigger, transition, style, animate, query, stagger} from '\\@angular/animations';\n * \\@Component({ \n *   templateUrl: 'list.component.html',\n *   animations: [\n *     trigger('listAnimation', [\n *        //...\n *     ])\n *   ]\n * })\n * class ListComponent {\n *   items = [];\n * \n *   showItems() {\n *     this.items = [0,1,2,3,4];\n *   }\n * \n *   hideItems() {\n *     this.items = [];\n *   }\n * \n *   toggle() {\n *     this.items.length ? this.hideItems() : this.showItems();\n *   }\n * }\n * ```\n * \n * And now for the animation trigger code:\n * \n * ```ts\n * trigger('listAnimation', [\n *   transition('* => *', [ // each time the binding value changes\n *     query(':leave', [\n *       stagger(100, [\n *         animate('0.5s', style({ opacity: 0 }))\n *       ])\n *     ]),\n *     query(':enter', [\n *       style({ opacity: 0 }),\n *       stagger(100, [\n *         animate('0.5s', style({ opacity: 1 }))\n *       ])\n *     ])\n *   ])\n * ])\n * ```\n * \n * Now each time the items are added/removed then either the opacity\n * fade-in animation will run or each removed item will be faded out.\n * When either of these animations occur then a stagger effect will be\n * applied after each item's animation is started.\n * \n * \\@experimental Animation support is experimental.\n * @param {?} timings\n * @param {?} animation\n * @return {?}\n */\nexport function stagger(\n    timings: string | number,\n    animation: AnimationMetadata | AnimationMetadata[]): AnimationStaggerMetadata {\n  return {type: AnimationMetadataType.Stagger, timings, animation};\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationOptions} from './animation_metadata';\nimport {AnimationPlayer} from './players/animation_player';\n/**\n * AnimationBuilder is an injectable service that is available when the {\\@link\n * BrowserAnimationsModule BrowserAnimationsModule} or {\\@link NoopAnimationsModule\n * NoopAnimationsModule} modules are used within an application.\n * \n * The purpose if this service is to produce an animation sequence programmatically within an\n * angular component or directive.\n * \n * Programmatic animations are first built and then a player is created when the build animation is\n * attached to an element.\n * \n * ```ts\n * // remember to include the BrowserAnimationsModule module for this to work...\n * import {AnimationBuilder} from '\\@angular/animations';\n * \n * class MyCmp {\n *   constructor(private _builder: AnimationBuilder) {}\n * \n *   makeAnimation(element: any) {\n *     // first build the animation\n *     const myAnimation = this._builder.build([\n *       style({ width: 0 }),\n *       animate(1000, style({ width: '100px' }))\n *     ]);\n * \n *     // then create a player from it\n *     const player = myAnimation.create(element);\n * \n *     player.play();\n *   }\n * }\n * ```\n * \n * When an animation is built an instance of {\\@link AnimationFactory AnimationFactory} will be\n * returned. Using that an {\\@link AnimationPlayer AnimationPlayer} can be created which can then be\n * used to start the animation.\n * \n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationBuilder {\n/**\n * @abstract\n * @param {?} animation\n * @return {?}\n */\nbuild(animation: AnimationMetadata|AnimationMetadata[]) {}\n}\n/**\n * An instance of `AnimationFactory` is returned from {\\@link AnimationBuilder#build\n * AnimationBuilder.build}.\n * \n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationFactory {\n/**\n * @abstract\n * @param {?} element\n * @param {?=} options\n * @return {?}\n */\ncreate(element: any, options?: AnimationOptions) {}\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}"],"names":["keyframes","tslib_1.__extends"],"mappings":"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"}