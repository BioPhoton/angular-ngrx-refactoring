{"version":3,"file":"animations-browser-testing.umd.min.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../../packages/animations/src/players/animation_player.ts","../../../../packages/animations/browser/src/render/shared.ts","../../../../../packages/animations/src/players/animation_group_player.ts","../../../../packages/animations/browser/src/util.ts","../../../../packages/animations/browser/testing/src/mock_animation_driver.ts","../../../../packages/animations/browser/testing/src/testing.ts","../../../../../packages/animations/src/animation_builder.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {scheduleMicroTask} from '../util';\n\n/**\n * AnimationPlayer controls an animation sequence that was produced from a programmatic animation.\n * (see {@link AnimationBuilder AnimationBuilder} for more information on how to create programmatic\n * animations.)\n *\n * @experimental Animation support is experimental.\n */\nexport interface AnimationPlayer {\n  onDone(fn: () => void): void;\n  onStart(fn: () => void): void;\n  onDestroy(fn: () => void): void;\n  init(): void;\n  hasStarted(): boolean;\n  play(): void;\n  pause(): void;\n  restart(): void;\n  finish(): void;\n  destroy(): void;\n  reset(): void;\n  setPosition(p: any /** TODO #9100 */): void;\n  getPosition(): number;\n  parentPlayer: AnimationPlayer|null;\n  readonly totalTime: number;\n  beforeDestroy?: () => any;\n}\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class NoopAnimationPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _onDestroyFns: Function[] = [];\nprivate _started = false;\nprivate _destroyed = false;\nprivate _finished = false;\npublic parentPlayer: AnimationPlayer|null = null;\npublic totalTime = 0;\nconstructor() {}\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nhasStarted(): boolean { return this._started; }\n/**\n * @return {?}\n */\ninit(): void {}\n/**\n * @return {?}\n */\nplay(): void {\n    if (!this.hasStarted()) {\n      this.triggerMicrotask();\n      this._onStart();\n    }\n    this._started = true;\n  }\n/**\n * @return {?}\n */\ntriggerMicrotask() { scheduleMicroTask(() => this._onFinish()); }\n/**\n * @return {?}\n */\nprivate _onStart() {\n    this._onStartFns.forEach(fn => fn());\n    this._onStartFns = [];\n  }\n/**\n * @return {?}\n */\npause(): void {}\n/**\n * @return {?}\n */\nrestart(): void {}\n/**\n * @return {?}\n */\nfinish(): void { this._onFinish(); }\n/**\n * @return {?}\n */\ndestroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      if (!this.hasStarted()) {\n        this._onStart();\n      }\n      this.finish();\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @return {?}\n */\nreset(): void {}\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void {}\n/**\n * @return {?}\n */\ngetPosition(): number { return 0; }\n}\n\nfunction NoopAnimationPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopAnimationPlayer.prototype._onDoneFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._onStartFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._onDestroyFns;\n/** @type {?} */\nNoopAnimationPlayer.prototype._started;\n/** @type {?} */\nNoopAnimationPlayer.prototype._destroyed;\n/** @type {?} */\nNoopAnimationPlayer.prototype._finished;\n/** @type {?} */\nNoopAnimationPlayer.prototype.parentPlayer;\n/** @type {?} */\nNoopAnimationPlayer.prototype.totalTime;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData = {},\n    postStyles: ɵStyleData = {}): ɵStyleData[] {\n  const errors: string[] = [];\n  const normalizedKeyframes: ɵStyleData[] = [];\n  let previousOffset = -1;\n  let previousKeyframe: ɵStyleData|null = null;\n  keyframes.forEach(kf => {\n    const offset = kf['offset'] as number;\n    const isSameOffset = offset == previousOffset;\n    const normalizedKeyframe: ɵStyleData = (isSameOffset && previousKeyframe) || {};\n    Object.keys(kf).forEach(prop => {\n      let normalizedProp = prop;\n      let normalizedValue = kf[prop];\n      if (prop !== 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n        switch (normalizedValue) {\n          case PRE_STYLE:\n            normalizedValue = preStyles[prop];\n            break;\n\n          case AUTO_STYLE:\n            normalizedValue = postStyles[prop];\n            break;\n\n          default:\n            normalizedValue =\n                normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n            break;\n        }\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player.totalTime)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player.totalTime)));\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)));\n      break;\n  }\n}\n\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  const event = makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n  const data = (e as any)['_data'];\n  if (data != null) {\n    (event as any)['_data'] = data;\n  }\n  return event;\n}\n\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n\nexport function parseTimelineCommand(command: string): [string, string] {\n  const separatorPos = command.indexOf(':');\n  const id = command.substring(1, separatorPos);\n  const action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n\nlet _contains: (elm1: any, elm2: any) => boolean = (elm1: any, elm2: any) => false;\nlet _matches: (element: any, selector: string) => boolean = (element: any, selector: string) =>\n    false;\nlet _query: (element: any, selector: string, multi: boolean) => any[] =\n    (element: any, selector: string, multi: boolean) => {\n      return [];\n    };\n\nif (typeof Element != 'undefined') {\n  // this is well supported in all browsers\n  _contains = (elm1: any, elm2: any) => { return elm1.contains(elm2) as boolean; };\n\n  if (Element.prototype.matches) {\n    _matches = (element: any, selector: string) => element.matches(selector);\n  } else {\n    const proto = Element.prototype as any;\n    const fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n        proto.oMatchesSelector || proto.webkitMatchesSelector;\n    if (fn) {\n      _matches = (element: any, selector: string) => fn.apply(element, [selector]);\n    }\n  }\n\n  _query = (element: any, selector: string, multi: boolean): any[] => {\n    let results: any[] = [];\n    if (multi) {\n      results.push(...element.querySelectorAll(selector));\n    } else {\n      const elm = element.querySelector(selector);\n      if (elm) {\n        results.push(elm);\n      }\n    }\n    return results;\n  };\n}\n\nexport const matchesElement = _matches;\nexport const containsElement = _contains;\nexport const invokeQuery = _query;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {scheduleMicroTask} from '../util';\nimport {AnimationPlayer} from './animation_player';\nexport class AnimationGroupPlayer implements AnimationPlayer {\nprivate _onDoneFns: Function[] = [];\nprivate _onStartFns: Function[] = [];\nprivate _finished = false;\nprivate _started = false;\nprivate _destroyed = false;\nprivate _onDestroyFns: Function[] = [];\npublic parentPlayer: AnimationPlayer|null = null;\npublic totalTime: number = 0;\n/**\n * @param {?} _players\n */\nconstructor(private _players: AnimationPlayer[]) {\n    let doneCount = 0;\n    let destroyCount = 0;\n    let startCount = 0;\n    const total = this._players.length;\n\n    if (total == 0) {\n      scheduleMicroTask(() => this._onFinish());\n    } else {\n      this._players.forEach(player => {\n        player.parentPlayer = this;\n        player.onDone(() => {\n          if (++doneCount >= total) {\n            this._onFinish();\n          }\n        });\n        player.onDestroy(() => {\n          if (++destroyCount >= total) {\n            this._onDestroy();\n          }\n        });\n        player.onStart(() => {\n          if (++startCount >= total) {\n            this._onStart();\n          }\n        });\n      });\n    }\n\n    this.totalTime = this._players.reduce((time, player) => Math.max(time, player.totalTime), 0);\n  }\n/**\n * @return {?}\n */\nprivate _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n/**\n * @return {?}\n */\ninit(): void { this._players.forEach(player => player.init()); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonStart(fn: () => void): void { this._onStartFns.push(fn); }\n/**\n * @return {?}\n */\nprivate _onStart() {\n    if (!this.hasStarted()) {\n      this._onStartFns.forEach(fn => fn());\n      this._onStartFns = [];\n      this._started = true;\n    }\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDone(fn: () => void): void { this._onDoneFns.push(fn); }\n/**\n * @param {?} fn\n * @return {?}\n */\nonDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n/**\n * @return {?}\n */\nhasStarted() { return this._started; }\n/**\n * @return {?}\n */\nplay() {\n    if (!this.parentPlayer) {\n      this.init();\n    }\n    this._onStart();\n    this._players.forEach(player => player.play());\n  }\n/**\n * @return {?}\n */\npause(): void { this._players.forEach(player => player.pause()); }\n/**\n * @return {?}\n */\nrestart(): void { this._players.forEach(player => player.restart()); }\n/**\n * @return {?}\n */\nfinish(): void {\n    this._onFinish();\n    this._players.forEach(player => player.finish());\n  }\n/**\n * @return {?}\n */\ndestroy(): void { this._onDestroy(); }\n/**\n * @return {?}\n */\nprivate _onDestroy() {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      this._onFinish();\n      this._players.forEach(player => player.destroy());\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n/**\n * @return {?}\n */\nreset(): void {\n    this._players.forEach(player => player.reset());\n    this._destroyed = false;\n    this._finished = false;\n    this._started = false;\n  }\n/**\n * @param {?} p\n * @return {?}\n */\nsetPosition(p: number): void {\n    const /** @type {?} */ timeAtPosition = p * this.totalTime;\n    this._players.forEach(player => {\n      const /** @type {?} */ position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;\n      player.setPosition(position);\n    });\n  }\n/**\n * @return {?}\n */\ngetPosition(): number {\n    let /** @type {?} */ min = 0;\n    this._players.forEach(player => {\n      const /** @type {?} */ p = player.getPosition();\n      min = Math.min(p, min);\n    });\n    return min;\n  }\n/**\n * @return {?}\n */\nget players(): AnimationPlayer[] { return this._players; }\n/**\n * @return {?}\n */\nbeforeDestroy(): void {\n    this.players.forEach(player => {\n      if (player.beforeDestroy) {\n        player.beforeDestroy();\n      }\n    });\n  }\n}\n\nfunction AnimationGroupPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nAnimationGroupPlayer.prototype._onDoneFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype._onStartFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype._finished;\n/** @type {?} */\nAnimationGroupPlayer.prototype._started;\n/** @type {?} */\nAnimationGroupPlayer.prototype._destroyed;\n/** @type {?} */\nAnimationGroupPlayer.prototype._onDestroyFns;\n/** @type {?} */\nAnimationGroupPlayer.prototype.parentPlayer;\n/** @type {?} */\nAnimationGroupPlayer.prototype.totalTime;\n/** @type {?} */\nAnimationGroupPlayer.prototype._players;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateTimings, AnimationMetadata, AnimationOptions, sequence, ɵStyleData} from '@angular/animations';\n\nexport const ONE_SECOND = 1000;\n\nexport const SUBSTITUTION_EXPR_START = '{{';\nexport const SUBSTITUTION_EXPR_END = '}}';\nexport const ENTER_CLASSNAME = 'ng-enter';\nexport const LEAVE_CLASSNAME = 'ng-leave';\nexport const ENTER_SELECTOR = '.ng-enter';\nexport const LEAVE_SELECTOR = '.ng-leave';\nexport const NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const NG_ANIMATING_SELECTOR = '.ng-animating';\n\nexport function resolveTimingValue(value: string | number) {\n  if (typeof value == 'number') return value;\n\n  const matches = (value as string).match(/^(-?[\\.\\d]+)(m?s)/);\n  if (!matches || matches.length < 2) return 0;\n\n  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n\nfunction _convertTimeValueToMS(value: number, unit: string): number {\n  switch (unit) {\n    case 's':\n      return value * ONE_SECOND;\n    default:  // ms or something else\n      return value;\n  }\n}\n\nexport function resolveTiming(\n    timings: string | number | AnimateTimings, errors: any[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ?\n      <AnimateTimings>timings :\n      parseTimeExpression(<string|number>timings, errors, allowNegativeValues);\n}\n\nfunction parseTimeExpression(\n    exp: string | number, errors: string[], allowNegativeValues?: boolean): AnimateTimings {\n  const regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let duration: number;\n  let delay: number = 0;\n  let easing: string = '';\n  if (typeof exp === 'string') {\n    const matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: ''};\n    }\n\n    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n\n    const delayMatch = matches[3];\n    if (delayMatch != null) {\n      delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\n    }\n\n    const easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = <number>exp;\n  }\n\n  if (!allowNegativeValues) {\n    let containsErrors = false;\n    let startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(`Duration values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(`Delay values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, `The provided timing value \"${exp}\" is invalid.`);\n    }\n  }\n\n  return {duration, delay, easing};\n}\n\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => { destination[prop] = obj[prop]; });\n  return destination;\n}\n\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    copyObj(styles, destination);\n  }\n  return destination;\n}\n\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = styles[prop];\n    });\n  }\n}\n\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = '';\n    });\n  }\n}\n\nexport function normalizeAnimationEntry(steps: AnimationMetadata | AnimationMetadata[]):\n    AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return steps as AnimationMetadata;\n}\n\nexport function validateStyleParams(\n    value: string | number, options: AnimationOptions, errors: any[]) {\n  const params = options.params || {};\n  const matches = extractStyleParams(value);\n  if (matches.length) {\n    matches.forEach(varName => {\n      if (!params.hasOwnProperty(varName)) {\n        errors.push(\n            `Unable to resolve the local animation param ${varName} in the given list of values`);\n      }\n    });\n  }\n}\n\nconst PARAM_REGEX =\n    new RegExp(`${SUBSTITUTION_EXPR_START}\\\\s*(.+?)\\\\s*${SUBSTITUTION_EXPR_END}`, 'g');\nexport function extractStyleParams(value: string | number): string[] {\n  let params: string[] = [];\n  if (typeof value === 'string') {\n    const val = value.toString();\n\n    let match: any;\n    while (match = PARAM_REGEX.exec(val)) {\n      params.push(match[1] as string);\n    }\n    PARAM_REGEX.lastIndex = 0;\n  }\n  return params;\n}\n\nexport function interpolateParams(\n    value: string | number, params: {[name: string]: any}, errors: any[]): string|number {\n  const original = value.toString();\n  const str = original.replace(PARAM_REGEX, (_, varName) => {\n    let localVal = params[varName];\n    // this means that the value was never overidden by the data passed in by the user\n    if (!params.hasOwnProperty(varName)) {\n      errors.push(`Please provide a value for the animation param ${varName}`);\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n\n  // we do this to assert that numeric values stay as they are\n  return str == original ? value : str;\n}\n\nexport function iteratorToArray(iterator: any): any[] {\n  const arr: any[] = [];\n  let item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n\nexport function mergeAnimationOptions(\n    source: AnimationOptions, destination: AnimationOptions): AnimationOptions {\n  if (source.params) {\n    const p0 = source.params;\n    if (!destination.params) {\n      destination.params = {};\n    }\n    const p1 = destination.params;\n    Object.keys(p0).forEach(param => {\n      if (!p1.hasOwnProperty(param)) {\n        p1[param] = p0[param];\n      }\n    });\n  }\n  return destination;\n}\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function allowPreviousPlayerStylesMerge(duration: number, delay: number) {\n  return duration === 0 || delay === 0;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../../src/render/animation_driver';\nimport {containsElement, invokeQuery, matchesElement} from '../../src/render/shared';\nimport {allowPreviousPlayerStylesMerge} from '../../src/util';\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationDriver implements AnimationDriver {\n  static log: AnimationPlayer[] = [];\n\n  matchesElement(element: any, selector: string): boolean {\n    return matchesElement(element, selector);\n  }\n\n  containsElement(elm1: any, elm2: any): boolean { return containsElement(elm1, elm2); }\n\n  query(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n\n  computeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n\n  animate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): MockAnimationPlayer {\n    const player =\n        new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\n    MockAnimationDriver.log.push(<AnimationPlayer>player);\n    return player;\n  }\n}\n\n/**\n * @experimental Animation support is experimental.\n */\nexport class MockAnimationPlayer extends NoopAnimationPlayer {\n  private __finished = false;\n  private __started = false;\n  public previousStyles: {[key: string]: string | number} = {};\n  private _onInitFns: (() => any)[] = [];\n  public currentSnapshot: ɵStyleData = {};\n\n  constructor(\n      public element: any, public keyframes: {[key: string]: string | number}[],\n      public duration: number, public delay: number, public easing: string,\n      public previousPlayers: any[]) {\n    super();\n\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousPlayers.forEach(player => {\n        if (player instanceof MockAnimationPlayer) {\n          const styles = player.currentSnapshot;\n          Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n        }\n      });\n    }\n\n    this.totalTime = delay + duration;\n  }\n\n  /* @internal */\n  onInit(fn: () => any) { this._onInitFns.push(fn); }\n\n  /* @internal */\n  init() {\n    super.init();\n    this._onInitFns.forEach(fn => fn());\n    this._onInitFns = [];\n  }\n\n  finish(): void {\n    super.finish();\n    this.__finished = true;\n  }\n\n  destroy(): void {\n    super.destroy();\n    this.__finished = true;\n  }\n\n  /* @internal */\n  triggerMicrotask() {}\n\n  play(): void {\n    super.play();\n    this.__started = true;\n  }\n\n  hasStarted() { return this.__started; }\n\n  beforeDestroy() {\n    const captures: ɵStyleData = {};\n\n    Object.keys(this.previousStyles).forEach(prop => {\n      captures[prop] = this.previousStyles[prop];\n    });\n\n    if (this.hasStarted()) {\n      // when assembling the captured styles, it's important that\n      // we build the keyframe styles in the following order:\n      // {other styles within keyframes, ... previousStyles }\n      this.keyframes.forEach(kf => {\n        Object.keys(kf).forEach(prop => {\n          if (prop != 'offset') {\n            captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\n          }\n        });\n      });\n    }\n\n    this.currentSnapshot = captures;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {MockAnimationDriver, MockAnimationPlayer} from './mock_animation_driver';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AnimationMetadata, AnimationOptions} from './animation_metadata';\nimport {AnimationPlayer} from './players/animation_player';\n/**\n * AnimationBuilder is an injectable service that is available when the {\\@link\n * BrowserAnimationsModule BrowserAnimationsModule} or {\\@link NoopAnimationsModule\n * NoopAnimationsModule} modules are used within an application.\n * \n * The purpose if this service is to produce an animation sequence programmatically within an\n * angular component or directive.\n * \n * Programmatic animations are first built and then a player is created when the build animation is\n * attached to an element.\n * \n * ```ts\n * // remember to include the BrowserAnimationsModule module for this to work...\n * import {AnimationBuilder} from '\\@angular/animations';\n * \n * class MyCmp {\n *   constructor(private _builder: AnimationBuilder) {}\n * \n *   makeAnimation(element: any) {\n *     // first build the animation\n *     const myAnimation = this._builder.build([\n *       style({ width: 0 }),\n *       animate(1000, style({ width: '100px' }))\n *     ]);\n * \n *     // then create a player from it\n *     const player = myAnimation.create(element);\n * \n *     player.play();\n *   }\n * }\n * ```\n * \n * When an animation is built an instance of {\\@link AnimationFactory AnimationFactory} will be\n * returned. Using that an {\\@link AnimationPlayer AnimationPlayer} can be created which can then be\n * used to start the animation.\n * \n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationBuilder {\n/**\n * @abstract\n * @param {?} animation\n * @return {?}\n */\nbuild(animation: AnimationMetadata|AnimationMetadata[]) {}\n}\n/**\n * An instance of `AnimationFactory` is returned from {\\@link AnimationBuilder#build\n * AnimationBuilder.build}.\n * \n * \\@experimental Animation support is experimental.\n * @abstract\n */\nexport abstract class AnimationFactory {\n/**\n * @abstract\n * @param {?} element\n * @param {?=} options\n * @return {?}\n */\ncreate(element: any, options?: AnimationOptions) {}\n}\n"],"names":["extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","NoopAnimationPlayer","this","_onDestroyFns","_started","totalTime","_finished","prototype","onStart","fn","_onStartFns","push","init","play","finish","_onFinish","destroy","_onStart","reset","_contains","AnimationGroupPlayer","_players","_this","_onDoneFns","_destroyed","parentPlayer","doneCount","destroyCount","startCount","total","length","scheduleMicroTask","forEach","player","onDone","onDestroy","_onDestroy","reduce","time","Math","max","hasStarted","setPosition","timeAtPosition","min","getPosition","configurable","beforeDestroy","elm1","elm2","_query","element","selector","multi","Element","contains","matches","_matches","proto","fn_1","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","apply","results","querySelectorAll","elm","querySelector","MockAnimationDriver","matchesElement","containsElement","query","computeStyle","prop","defaultValue","previousPlayers","MockAnimationPlayer","keyframes$$1","duration","delay","easing","log","tslib_1.__extends","_super","call","keyframes","__finished","__started","previousStyles","_onInitFns","currentSnapshot","styles_1","__extends","onInit","triggerMicrotask","kf","exports","module","factory"],"mappings":"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"}